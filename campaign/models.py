# -*- coding: utf-8 -*-

import datetime

from django.db import models
from django.db.models import permalink
from django.contrib.auth.models import User
from django.contrib.localflavor.us.models import PhoneNumberField
from tagging.models import Tag
from template_utils import markup
from template_utils.markup import formatter

from campaign import managers


STATUS_CHOICES = (
    (1, u'Public'),
    (2, u'Draft'),
    (3, u'Hidden'),
)


TITLE_CHOICES = (
    ('mr.',   u'Mr.'),
    ('ms.',   u'Ms.'),
    ('mrs.',  u'Mrs.'),
    ('dr.',   u'Dr.'),
    ('rev.',  u'Rev.'),
    ('sen.',  u'Sen.'),
    ('rep.',  u'Rep.'),
    ('gov.',  u'Gov.'),
    ('mayor', u'Mayor'),
)


class Supporter(models.Model):
    """
    A supporter of the political candidate / campaign. This 
    information will be gathered by a form on the site.
    
    """
    # Supporter
    first_name = models.CharField(u'First name(s)', max_length=32)
    last_name = models.CharField(max_length=32)
    title = models.CharField(max_length=32, choices=TITLE_CHOICES, blank=True)
    organization = models.CharField(max_length=64, blank=True)
    
    # Contact info
    address_1 = models.CharField(max_length=100, blank=True)
    address_2 = models.CharField(max_length=100, blank=True)
    city = models.CharField(max_length=100, default=u'Rexburg')
    state = models.CharField(max_length=32, default=u'ID')
    country = models.CharField(max_length=100, default=u'USA')
    zip_code = models.CharField(u'ZIP / Postal code', max_length=32, default='83440')
    email = models.EmailField(unique=True)
    phone = PhoneNumberField(blank=True)
    
    # Supporting actions
    message = models.TextField(blank=True)
    support_list = models.BooleanField(default=True)
    yard_sign = models.BooleanField(default=True)
    poster = models.BooleanField()
    volunteer = models.BooleanField()
    fundraising = models.BooleanField()
    donated = models.BooleanField()
    
    # Follow-up
    contacted = models.BooleanField()
    yard_sign_delivered = models.BooleanField()
    poster_delivered = models.BooleanField()
    
    # Meta
    ip_address = models.IPAddressField(u'IP address', blank=True, null=True)
    submit_date = models.DateTimeField(u'date / time submitted',)
    status = models.IntegerField(max_length=1, choices=STATUS_CHOICES, default=1, help_text=u'Only supporters with &#8220;Public&#8221; status will be displayed publicly.')
    
    # Managers
    objects = models.Manager()
    public = managers.PublicSupporterManager()
    
    class Meta:
        ordering = ['-submit_date']
    
    def __unicode__(self):
        return u'%s, %s' % (self.last_name, self.first_name)


class Entry(models.Model):
    """
    An entry in the weblog.
    
    Slightly denormalized, because it uses two fields each for the
    excerpt and the body: one for the actual text the user types in,
    and another to store the HTML version of the Entry (e.g., as
    generated by a text-to-HTML converter like Textile or Markdown).
    This saves having to run the conversion each time the Entry is
    displayed.
    
    """
    
    # Metadata
    title = models.CharField(max_length=200)
    subtitle = models.CharField(u'Subtitle', max_length=200, blank=True)
    slug = models.SlugField(unique_for_date='pub_date', help_text=u'Used in the URL of the entry. Must be unique for the publication date of the entry.')
    author = models.ForeignKey(User, related_name='weblog_entries')
    pub_date = models.DateTimeField(u'Date published')
    
    # Entry
    summary_txt = models.TextField(u'Entry summary', help_text=u'<a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown dingus and syntax.">Markdown</a> allowed.', blank=True, null=True)
    summary = models.TextField(u'Entry summary as HTML', editable=False, blank=True, null=True)
    body_txt = models.TextField(u'Entry body', help_text=u'<a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown dingus and syntax.">Markdown</a> allowed.')
    body = models.TextField(u'Entry body as HTML', editable=False, blank=True,)
    
    # Categorization
    tag_list = models.CharField(max_length=200, help_text=u'oneword, lowercase, commaseparated')
    status = models.IntegerField(choices=STATUS_CHOICES, default=2, help_text=u'Only entries with &#8220;Public&#8221; status will be displayed publicly.')
    
    # Managers
    objects = models.Manager()
    public = managers.PublicItemManager()

    class Meta:
        verbose_name_plural = 'entries'
        ordering = ('-pub_date',)
        get_latest_by = 'pub_date'

    def __unicode__(self):
        return self.title
    
    def get_absolute_url(self):
        return ('django.views.generic.date_based.object_detail', (), { 'year': self.pub_date.strftime('%Y'),
                                                                       'month': self.pub_date.strftime('%b').lower(),
                                                                       'day': self.pub_date.strftime('%d'),
                                                                       'slug': self.slug })
    get_absolute_url = permalink(get_absolute_url)
    
    def _next_previous_helper(self, direction):
        return getattr(self, 'get_%s_by_pub_date' % direction)(status__exact=1)
    
    def get_next(self):
        """
        Returns the next Entry with ``is_public`` by ``pub_date``, if
        there is one, or ``None`` if there isn't.
        
        In public-facing views and templates, use this method instead
        of ``get_next_by_pub_date``, because ``get_next_by_pub_date``
        cannot differentiate published Entries.
        
        """
        return self._next_previous_helper('next')
    
    def get_previous(self):
        """
        Returns the previous Entry with ``is_public`` by ``pub_date``,
        if there is one, or ``None`` if there isn't.
        
        In public-facing views and templates, use this method instead
        of ``get_previous_by_pub_date``, because ``get_previous_by_pub_date``
        cannot differentiate published Entries.
        
        """
        return self._next_previous_helper('previous')
    
    def _get_tags(self):
        return Tag.objects.get_for_object(self)
    
    def _set_tags(self, tag_list):
        Tag.objects.update_tags(self, tag_list)
    
    tags = property(_get_tags, _set_tags)
    
    def save(self):
        """
        A custom save method to transform and store the text-to-HTML conversions.
        
        """
        if self.summary_txt:
            self.summary = formatter(self.summary_txt)
        self.body = formatter(self.body_txt)
        super(Entry, self).save()
        self.tags = self.tag_list


class Issue(models.Model):
    """
    An issue and the candidate's position.
    
    Slightly denormalized, because it uses two fields each for the
    position: one for the actual text the user types in, and another 
    to store the HTML version of the Entry (e.g., as generated by 
    a text-to-HTML converter like Textile or Markdown). This saves 
    having to run the conversion each time the Issue is displayed.
    
    """
    
    # Metadata
    issue = models.CharField(max_length=200)
    slug = models.SlugField(unique=True,)
    ordering = models.SmallIntegerField(default=0, help_text=u'High numbers are closer to the top of the list. Negative numbers are allowed.')
    
    # Position
    position_summary_txt = models.TextField(u'Position summary', help_text=u'<a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown dingus and syntax.">Markdown</a> allowed.', blank=True, null=True)
    position_summary = models.TextField(u'Position summary as HTML', editable=False, blank=True, null=True)
    position_txt = models.TextField(u'Position', help_text=u'<a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown dingus and syntax.">Markdown</a> allowed.')
    position = models.TextField(u'Position as HTML', blank=True)
    
    # Categorization
    tag_list = models.CharField(max_length=200, help_text=u'oneword, lowercase, commaseparated')
    status = models.IntegerField(choices=STATUS_CHOICES, default=2, help_text=u'Only issues with &#8220;Public&#8221; status will be displayed publicly.')
    
    # Managers
    objects = models.Manager()
    public = managers.PublicItemManager()

    class Meta:
        ordering = ('-ordering',)

    def __unicode__(self):
        return self.issue
    
    def get_absolute_url(self):
        return ('django.views.generic.list_detail.object_detail', [str(self.slug)])
    get_absolute_url = permalink(get_absolute_url)
    
    def get_next(self):
        try:
            return Issue.objects.filter(status__exact=1).filter(ordering__gt=self.ordering)[0]
        except IndexError:
            return u''
    
    def get_previous(self):
        try:
            return Issue.objects.filter(status__exact=1).filter(ordering__lt=self.ordering)[0]
        except IndexError:
            return u''
    
    def _get_tags(self):
        return Tag.objects.get_for_object(self)
    
    def _set_tags(self, tag_list):
        Tag.objects.update_tags(self, tag_list)
    
    tags = property(_get_tags, _set_tags)
    
    def save(self):
        self.position_summary = formatter(self.position_summary_txt)
        self.position = formatter(self.position_txt)
        super(Issue, self).save()
        self.tags = self.tag_list
